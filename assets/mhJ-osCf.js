const z={active:!0,breakpoints:{},snapped:"is-snapped",inView:"is-in-view",draggable:"is-draggable",dragging:"is-dragging",loop:"is-loop"};function d(s){return(Array.isArray(s)?s:[s]).filter(Boolean)}function p(s,n){!s||!n.length||s.classList.remove(...n)}function f(s,n){!s||!n.length||s.classList.add(...n)}function y(s={}){let n,i,l,w,u=[],b=[];const m=["select"],v=["pointerDown","pointerUp"],I=["slidesInView"],e={snapped:[],inView:[],draggable:[],dragging:[],loop:[]};function D(o,t){i=o;const{mergeOptions:g,optionsAtMedia:h}=t,C=g(z,y.globalOptions),a=g(C,s);n=h(a),l=i.rootNode(),w=i.slideNodes();const{watchDrag:x,loop:A}=i.internalEngine().options,k=!!x;n.loop&&A&&(e.loop=d(n.loop),f(l,e.loop)),n.draggable&&k&&(e.draggable=d(n.draggable),f(l,e.draggable)),n.dragging&&(e.dragging=d(n.dragging),v.forEach(r=>i.on(r,S))),n.snapped&&(e.snapped=d(n.snapped),m.forEach(r=>i.on(r,E)),E()),n.inView&&(e.inView=d(n.inView),I.forEach(r=>i.on(r,V)),V())}function O(){v.forEach(o=>i.off(o,S)),m.forEach(o=>i.off(o,E)),I.forEach(o=>i.off(o,V)),p(l,e.loop),p(l,e.draggable),p(l,e.dragging),c([],u,e.snapped),c([],b,e.inView),Object.keys(e).forEach(o=>{const t=o;e[t]=[]})}function S(o,t){(t==="pointerDown"?f:p)(l,e.dragging)}function c(o=[],t=[],g){const h=t.map(a=>w[a]),C=o.map(a=>w[a]);return h.forEach(a=>p(a,g)),C.forEach(a=>f(a,g)),o}function E(){const{slideRegistry:o}=i.internalEngine(),t=o[i.selectedScrollSnap()];u=c(t,u,e.snapped)}function V(){const o=i.slidesInView();b=c(o,b,e.inView)}return{name:"classNames",options:s,init:D,destroy:O}}y.globalOptions=void 0;export{y as default};
